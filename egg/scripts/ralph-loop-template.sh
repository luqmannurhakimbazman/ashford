#!/usr/bin/env bash
# Ralph Loop — Autonomous coding loop with per-task context assembly
# Generated by /ralph start. Safe to edit.

set -euo pipefail

RALPH_DIR="docs/ralph"
SPEC_FILE="$RALPH_DIR/SPEC.md"
PLAN_FILE="$RALPH_DIR/PLAN.md"
TASKS_DIR="$RALPH_DIR/tasks"
LOG_DIR="$RALPH_DIR/logs"
PROTOCOL_FILE="$RALPH_DIR/iteration-protocol.md"
ITERATION=0

mkdir -p "$LOG_DIR"

# --- Helper: extract a ## section from SPEC.md by heading name ---
extract_section() {
    local file="$1"
    local section="$2"
    awk -v section="$section" '
        BEGIN { found=0 }
        /^## / {
            if (found) exit
            gsub(/^## */, "")
            if ($0 == section) found=1
        }
        found { print }
    ' "$file"
}

# --- Helper: parse YAML frontmatter array field ---
parse_frontmatter_array() {
    local file="$1"
    local field="$2"
    sed -n '/^---$/,/^---$/p' "$file" \
        | grep "^${field}:" \
        | sed "s/^${field}: *\[//; s/\] *$//; s/, */\n/g"
}

# --- Helper: strip YAML frontmatter from a file ---
strip_frontmatter() {
    local file="$1"
    awk 'BEGIN{n=0} /^---$/{n++; if(n==2){getline; found=1}} found{print}' "$file"
}

# --- Preflight checks ---
for f in "$SPEC_FILE" "$PLAN_FILE" "$PROTOCOL_FILE"; do
    if [[ ! -f "$f" ]]; then
        echo "ERROR: Missing required file: $f"
        echo "Run the ralph planning skill first to generate artifacts."
        exit 1
    fi
done

if [[ ! -d "$TASKS_DIR" ]] || [[ -z "$(ls -A "$TASKS_DIR" 2>/dev/null)" ]]; then
    echo "ERROR: No task files found in $TASKS_DIR"
    exit 1
fi

echo "=== Ralph Loop Starting ==="
echo "Spec: $SPEC_FILE"
echo "Plan: $PLAN_FILE"
echo "Tasks: $(ls "$TASKS_DIR"/*.md 2>/dev/null | wc -l | tr -d ' ') task files"
echo ""

# --- Main loop ---
while :; do
    # Find next unchecked task number
    NEXT=$(grep -m1 '^\- \[ \]' "$PLAN_FILE" | grep -oE '[0-9]+' | head -1)

    if [[ -z "$NEXT" ]]; then
        echo ""
        echo "=== Ralph Loop Complete ==="
        echo "All tasks are complete or blocked."
        echo "Check $PLAN_FILE for final status."
        break
    fi

    ITERATION=$((ITERATION + 1))

    # Find the task file matching this number
    TASK_FILE=$(ls "$TASKS_DIR/${NEXT}-"*.md 2>/dev/null | head -1)

    if [[ -z "$TASK_FILE" ]]; then
        echo "WARNING: No task file found for task $NEXT. Skipping."
        # Mark as blocked to prevent infinite loop
        sed -i '' "s/^\(- \[ \] ${NEXT}\)/- [BLOCKED: task file missing] ${NEXT}/" "$PLAN_FILE" 2>/dev/null \
            || sed -i "s/^\(- \[ \] ${NEXT}\)/- [BLOCKED: task file missing] ${NEXT}/" "$PLAN_FILE"
        continue
    fi

    echo "--- Iteration $ITERATION: Task $NEXT ($(basename "$TASK_FILE")) ---"

    # Parse frontmatter declarations
    SECTIONS=$(parse_frontmatter_array "$TASK_FILE" "spec-sections")
    CODEBASE_FILES=$(parse_frontmatter_array "$TASK_FILE" "codebase-files")

    # Assemble the prompt dynamically
    PROMPT=""

    # 1. Inject declared spec sections
    if [[ -n "$SECTIONS" ]]; then
        PROMPT+="# Project Spec (relevant sections)\n\n"
        while IFS= read -r section; do
            section=$(echo "$section" | xargs)  # trim whitespace
            [[ -z "$section" ]] && continue
            EXTRACTED=$(extract_section "$SPEC_FILE" "$section")
            if [[ -n "$EXTRACTED" ]]; then
                PROMPT+="$EXTRACTED"
                PROMPT+="\n\n"
            else
                PROMPT+="## $section\n[Section not found in spec]\n\n"
            fi
        done <<< "$SECTIONS"
    fi

    # 2. Inject declared codebase files
    if [[ -n "$CODEBASE_FILES" ]]; then
        PROMPT+="# Codebase Files (current state)\n\n"
        while IFS= read -r filepath; do
            filepath=$(echo "$filepath" | xargs)  # trim whitespace
            [[ -z "$filepath" ]] && continue
            if [[ -f "$filepath" ]]; then
                PROMPT+="## File: $filepath\n\n\`\`\`\n"
                PROMPT+="$(cat "$filepath")"
                PROMPT+="\n\`\`\`\n\n"
            else
                PROMPT+="## File: $filepath\n[File not found — may not be created yet]\n\n"
            fi
        done <<< "$CODEBASE_FILES"
    fi

    # 3. Inject task details (without frontmatter)
    PROMPT+="# Your Task\n\n"
    PROMPT+="$(strip_frontmatter "$TASK_FILE")"
    PROMPT+="\n\n"

    # 4. Inject iteration protocol
    PROMPT+="$(cat "$PROTOCOL_FILE")"

    # Run Claude with assembled prompt
    echo -e "$PROMPT" | claude -p 2>&1 | tee "$LOG_DIR/iteration-$(printf '%02d' $ITERATION).log"

    echo ""
    echo "--- Iteration $ITERATION complete ---"
    echo ""
done

echo ""
echo "Logs: $LOG_DIR/"
echo "Plan: $PLAN_FILE"
